/** Polinomio.cpp */
//#define NDEBUG
#include <iostream>
using std::cout;
#include <assert.h>
#include "Polinomio.h"
/** Operador referencia a
 * Una referencia es un nombre alternativo (un sin\'onimo) para 
 * un objeto. Su utilizaci\'on la podemos observar en el dise\~no
 * de clases (por ejemplo, en el constructor de copia), en el valor 
 * retornado por una funci\'on para permitir que dicha funci\'on sea 
 * utilizada a ambos lados del operador de asignaci\'on (la funci\'on 
 * devuelve una referencia), o para permitir que los argumentos en la 
 * llamada puedan cambiar (paso de par\'ametros por referencia). La 
 * forma general de expresar una referencia es:
 * tipo& referencia=variable
 */

Polinomio& Polinomio::operator+(Polinomio& PolObj)
{
	int maxgrad=maximo(grado,PolObj.grado);
	Polinomio ResP(maxgrad,new Rac[maxgrad+1]);
	Polinomio& ResPol=ResP;   //Para devolver una referencia.
	if(grado==maxgrad){/*si el obj implicito es el de mayor grado*/
		for(int i=0;i<grado+1;i++){
			(ResPol.A+i)->n=(A+i)->n;
			(ResPol.A+i)->d=(A+i)->d;
		}
	}else{/*si el segundo operando es el de mayor grado*/
		for(int i=0;i<PolObj.grado+1;i++){
			(ResPol.A+i)->n=(PolObj.A+i)->n;
			(ResPol.A+i)->d=(PolObj.A+i)->d;
		}
	}
	if(grado==maxgrad){/*si el objeto implicito es el polinomio de mayor grado*/
		//FIXMEEEEEEE!!!!!!        FIXED: 2018.06.25.16.36
		// i\in\{0,1,2,...,grado\} y queremos que los coeficientes del objeto 
		// impl\'icito se le sumen a los coeficientes del resultado correspondientes
		// a los \'indices \{grad - grado +0,grad - grado +1...,grad - 2,grad - 1,grad\} 
		for(int i=PolObj.grado;i>=0;i--){
			*(ResPol.A+ResPol.grado-(PolObj.grado-i))=*(ResPol.A+ResPol.grado-(PolObj.grado-i))+*(PolObj.A+i);
		}
	}else{/*si el segundo operando es el de menor grado*/
		for(int i=grado;i>=0;i--){
			*(ResPol.A+ResPol.grado-(grado-i))=*(ResPol.A+ResPol.grado-(grado-i))+*(A+i);
		}
	}
	return ResPol;
}

Polinomio& Polinomio::operator-(Polinomio& PolObj)
{
	int grad;
	Polinomio& ResPol=PolObj;//Polinomio P(1,new Rac[2]);
	if(grado==PolObj.grado){//cout<<"AQUI"<<endl;
      Polinomio ResP1(grado,new Rac[grado+1]);
      ResPol=ResP1;
      for(int i=0;i<grado+1;i++){
        (ResPol.A+i)->n=(A+i)->n;
        (ResPol.A+i)->d=(A+i)->d;
      }
      for(int i=0;i<grado+1;i++){
			*(ResPol.A+i)=*(A+i)-*(PolObj.A+i);//cout<<"AQUI: "<<*(A+i)<<" - "<<*(PolObj.A+i)<<endl;
	  }
	}else{
	  grad=maximo(grado,PolObj.grado);
	  Polinomio ResP(grad,new Rac[grad+1]);
	  ResPol=ResP;
	  if(grado==grad){/*si el obj implicito es el de mayor grado*/
		for(int i=0;i<grado+1;i++){
			(ResPol.A+i)->n=(A+i)->n;
			(ResPol.A+i)->d=(A+i)->d;
		}
	  }else{/*si el segundo operando es el de mayor grado*/
		for(int i=0;i<PolObj.grado+1;i++){
			(ResPol.A+i)->n=(-1)*((PolObj.A+i)->n);
			(ResPol.A+i)->d=(PolObj.A+i)->d;
		}
      }
	  if(grado==grad){/*si el objeto implicito es el polinomio de mayor grado*/
		for(int i=PolObj.grado;i>=0;i--){
			*(ResPol.A+ResPol.grado-(PolObj.grado-i))=*(ResPol.A+ResPol.grado-(PolObj.grado-i))-*(PolObj.A+i);
		}
	  }else{/*si el segundo operando es el de mayor grado*/
		for(int i=grado;i>=0;i--){
			*(ResPol.A+ResPol.grado-(grado-i))=*(ResPol.A+ResPol.grado-(grado-i))+*(A+i);
		}
	  }
    }
	return ResPol;
}



Polinomio& Polinomio::operator*(Polinomio& PolObj)
{
	int grad=grado+PolObj.grado;
	Polinomio ResP(grad,new Rac[grad+1]);
	Polinomio& ResPol=ResP;		/* ResultPolynomial */
	Rac factor1,factor2,factor1porfactor2,sumaparcial;
	for(int i=0;i<ResPol.grado+1;i++){
		*(ResPol.A+i)=Rac(0,1);	/* All coeffs of ResPol must be initialized  to \frac{0}{1} */
	}
	for(int k=0;k<grad+1;k++){
		for(int i=0;i<grado+1;i++){
			for(int j=0;j<PolObj.grado+1;j++){
				if((grado-i+PolObj.grado-j)==grad-k){
					factor1=*(A+i);
					factor2=*(new Rac((PolObj.A+j)->n,(PolObj.A+j)->d));
					factor1porfactor2=factor1*factor2;
					sumaparcial=*(ResPol.A+k)+factor1porfactor2;
					*(ResPol.A+k)=sumaparcial;
				}
			}
		}
	}
	return ResPol;
}

//FcnDTrans& Polinomio::operator/(Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B4F begin
//{
//}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B4F end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

ostream&  operator<<(ostream& ostreamOut, Polinomio& PolObj)
{ 
  Rac *rPt;
  int intV;
  ostreamOut<<"\\begin{array}{";
  for(int j=0;j<PolObj.grado+1;j++){
  	ostreamOut<<"c";
  }
  ostreamOut<<"}"<<endl;
 for(int i=0;i<PolObj.grado+1;i++){
 	rPt=(PolObj.A+i);
 	intV=rPt->n;
// 	cout<<"intV="<<intV<<endl;
	 if((PolObj.A+i)->d==1){
 		if(i){
 			ostreamOut<<"&"<<intV<<endl;
		 }else{
		 	ostreamOut<<intV<<endl;
		 }
	 }else{
		if(i){
	 		ostreamOut<<"&\\frac{"<<intV<<"}{"<<(PolObj.A+i)->d<<"}"<<endl;
		 }else{
	 		ostreamOut<<"\\frac{"<<intV<<"}{"<<(PolObj.A+i)->d<<"}"<<endl;
		 }
 	 }
  }
  ostreamOut<<"\\end{array}"<<endl;
  return ostreamOut;
}

Polinomio::Polinomio(int intGrado, Rac * RacPt):grado(intGrado),A(RacPt)
{ }

std::string Polinomio::string_show(){
	string Result="";
//	for(int i=0;i<grado+1;i++){
	for(int i=0;i<grado;i++){
		Result+=A[i].string_show()+":";
	}
	Result+=A[grado].string_show();
	return Result;
}

